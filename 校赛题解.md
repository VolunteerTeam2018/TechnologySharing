# 题解

## A

题意就是找出所有的单身狗，然后题目保证了单身狗居多，所以我们并不用考虑现充的影响，他们投票是无效的，意味着我们只需要考虑哪些人的得票数大于一半，就可以了，等于是开一个一维数组保存，最后遍历一遍就行。oj不支持忽略行末空格，所以需要进行处理，不然会导致PE.

## E

这题主要是给了一些点，点与点之间有无向边，所以可以看作一个在t步之内我们到达其他所有点的种类数之和（有点绕）。那么我们从一个点到另一个点的种类数如果我们规定需要走t步，那么我们可以利用离散中的知识得出，将邻接矩阵的t次方计算出来，然后找到对应的位置，该位置对应的数字就是种类数。那么现在我们需要知道的是t步之内，所以我们需要将从1次方到t次方的矩阵相加起来，因为范围比较大所以我们可以利用快速幂的思想，来二分求解，那么问题我们就转化成了一个二分等比矩阵求和的问题。然后题目规定了起点，我们只需要将所得矩阵的第一行相加，最后输出答案的时候加一即可（因为可以在1处直接抓人）。总体复杂度应该是nlogn，集训队里面有两个神仙用dp+xjr优化过了这题，期待他们的题解。

## F

这个是一个依赖背包裸题，实际上就是路径压缩的并查集+01背包，因为每一个有依赖的物品我们就可以直接看作同一个物品，所以，我们可以先利用并查集处理一下，然后保存的就是我们真实需要处理的物品，之后利用01背包求解即可。

## G

这题本质上就是一个大模拟，看懂代码应该就能写，主要卡点在于位运算可逆，如果知道这一个，那么就可以根据所给代码进行反推，进行一次大模拟。群里之前有人问样例为什么是两个数字，这是因为给的n是2，所以会加密出两个数字。

## I

这题是一个dfs的基础进阶题，因为规定了走的步数，所以用bfs找到最短路径的方法就被毙了。那么我们只要一直进行dfs直到t步数的时候一直return就行，如果没有答案，那也就return。但是这题数据范围比较大，所以我们需要在刚开始和dfs的时候进行剪枝，一次是t大于所有可走点，一次是奇偶性不同（剩余时间和离终点的曼哈顿距离），还有一次是剩余时间小于离终点的曼哈顿距离，理论上剪完这三个枝，就可以通过这一题。

## J

水题无疑，刚开始没看清楚数据范围（眼瞎了），后来直接上大数板子就可以过了，这题就是一个斐波那契的问题，因为可以转化为f(n) = f(n - 1) + f(n - 2)，所以就是一个斐波那契加高精的一个裸题。注意不要写成递归，如果数据再大一点就会导致爆栈。整体时间复杂度为O(n)，常数主要是在实现大数上。